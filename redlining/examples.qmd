

```{r}
library(dplyr)
library(duckdbfs)
duckdb_secrets("", "", "s3-west.nrp-nautilus.io")

# edit these filters as you like
gbif <- open_dataset("s3://public-gbif/2025-06/hex") |>
    filter(
        `class` == "Aves",
        institutioncode %in% c("CLO", "iNaturalist")
    )

# hexes
redlining <- open_dataset("s3://public-redlining/hex") |>
 mutate(h10 = sql("('0x' || h10)::UBIGINT")) # hotfix to join ints, will fix

# compute areas based on hex means
hex_area <- redlining |>
    group_by(area_id) |>
    summarise(area = n() * 0.015047502)

dt <- redlining |> left_join(gbif, by = c("h0", "h10"))

```


Density: hex counts, hex areas:

```{r}
system.time({
dt |>
    count(area_id, grade, year, institutioncode) |>
    inner_join(hex_area) |>
    mutate(count_density = n / area) |>
    write_dataset("count_density_km2.parquet")
    })
```


Timeseries plot:

```{r}
library(dplyr)
library(ggplot2)
trend <- open_dataset("count_density_km2.parquet") |>
    filter(!is.na(year)) |>
    filter(grade %in% c("A", "B", "C", "D")) |>
    filter(year > 2000) |>
    group_by(grade, year, ) |>
    summarise(mean = mean(count_density)) |>
    arrange(desc(mean))


trend |>
    ggplot(aes(year, mean, col = grade)) +
    geom_line(lwd = 1) +
    # geom_col(pos = "dodge") +
    theme_bw() +
    scale_colour_manual(values = c("A" = "#76b583", "B" = "#6eb6c5", "C" = "#ffe56d", "D" = "#e07856"))
```







-------------


Quality test: h10-hex based areas aren't perfect but pretty good.  


```{r}

# polygons -- for more 'exact' area, Albers equal areas projection
polys <- open_dataset("s3://public-redlining/mappinginequality.parquet", recursive = FALSE) |>
   mutate(geom = ST_Transform(ST_FlipCoordinates(st_MakeValid(geometry)), 'EPSG:4326', 'EPSG:5070')) |> # lots are lost
   mutate(area = st_area(geom) / 1000000.0) |>
   select(area_id, city, area)
```

```{r}
# check our area math
area_approx = hex_area |> 
  rename(hex_area = area) |>
  inner_join(polys) |>
  mutate(ratio = area / hex_area ) |>
  arrange(desc(ratio))

area_approx |> pull(ratio) |> hist()
```


We can of course do a proper spatial polygon-contains-points join instead of the hex joins above, presumably a bit slower...

```{r}

gbif_pts <- gbif |> mutate(geom = st_point(decimallongitude, decimallatitude))
red_polys <- open_dataset("s3://public-redlining/mappinginequality.parquet", recursive = FALSE) |> rename(geom = geometry)

dt_spatial <- red_polys |> spatial_join(gbif_pts, by = "st_intersects")

# here we go
system.time({
dt_spatial |>
    count(area_id, grade, year, institutioncode) |>
    inner_join(polys) |> # exact areas
    mutate(count_density = n / area) |>
    write_dataset("count_density_exact.parquet")

})
```

